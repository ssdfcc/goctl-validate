package main

import (
	"bytes"
	"fmt"
	"html/template"
	"os"
	"path"
	"runtime/debug"
	"slices"
	"strings"

	"github.com/zeromicro/go-zero/tools/goctl/api/gogen"
	"github.com/zeromicro/go-zero/tools/goctl/plugin"
)

const (
	interval = "internal/"

	typesPacket          = "types"
	typesDir             = interval + typesPacket
	projectOpenSourceUrl = "github.com/zeromicro/go-zero"
	filename             = "validate.go"
	handlerHeader        = `// Code generated by goctl-validate. DO NOT EDIT.
// goctl 1.7.5

package types

import (
	"errors"
	"fmt"
	chinese "github.com/go-playground/locales/zh"
	ut "github.com/go-playground/universal-translator"
	"github.com/go-playground/validator/v10"
	zhTranslations "github.com/go-playground/validator/v10/translations/zh"
	"reflect"
	"strings"
)

// CustomValidator represents a validator.
type CustomValidator interface {
	// CustomValidate validates the value.
	CustomValidate() error
}

var validate *validator.Validate
var trans ut.Translator

func init() {
	zh := chinese.New()
	uni := ut.New(zh, zh)
	trans, _ = uni.GetTranslator("zh")
	validate = validator.New()
	validate.RegisterTagNameFunc(func(field reflect.StructField) string {
		label := field.Tag.Get("label")
		if label == "" {
			return field.Name
		}
		return label
	})
	_ = zhTranslations.RegisterDefaultTranslations(validate, trans)
}

func translate(errs error) error {
	var errList []string
	var v validator.ValidationErrors
	switch {
	case errors.As(errs, &v):
		for _, e := range v {
			errList = append(errList, e.Translate(trans))
		}
		return fmt.Errorf(strings.Join(errList, "|"))
	default:
		return errs
	}
}
`
	handlerTemplate = `
{{range $index, $type :=.RequestTypes}}
func (r *{{$type}})Validate() error {
	if valid, ok := interface{}(r).(CustomValidator); ok {
		return valid.CustomValidate()
	} else if err := validate.Struct(r); err != nil {
		return translate(err)
	}
	return nil
}
{{end}}`
)

type Handler struct {
	RequestTypes []string
}

func main() {
	plugin1, err := plugin.NewPlugin()
	if err != nil {
		panic(err)
	}

	if len(plugin1.Style) == 0 {
		plugin1.Style = "gozero"
	}

	err = gogen.DoGenProject(plugin1.ApiFilePath, plugin1.Dir, strings.TrimSpace(plugin1.Style))
	if err != nil {
		panic(err)
	}

	var api = plugin1.Api
	filePath := path.Join(plugin1.Dir, typesDir, filename)
	handleObj := Handler{
		RequestTypes: make([]string, 0),
	}
	for _, t := range api.Service.Routes() {
		if len(t.RequestTypeName()) > 0 && !slices.Contains(handleObj.RequestTypes, t.RequestTypeName()) {
			handleObj.RequestTypes = append(handleObj.RequestTypes, t.RequestTypeName())
		}
	}
	if len(handleObj.RequestTypes) > 0 {
		_ = os.Remove(path.Join(plugin1.Dir, filePath))
		err := gen(filePath, handleObj)
		if err != nil {
			debug.PrintStack()
			panic(err)
		}
	}
}

func gen(filePath string, handleObj Handler) error {
	if err := ensurePathExists(path.Dir(filePath)); err != nil {
		return err
	}

	fp, err := os.OpenFile(filePath, os.O_CREATE|os.O_RDWR, 0755)
	if err != nil {
		return err
	}
	defer fp.Close()

	buffer := new(bytes.Buffer)
	if err := template.Must(template.New("validateTemplate").Parse(handlerTemplate)).Execute(buffer, handleObj); err != nil {
		return err
	}

	if _, err := fp.WriteString(handlerHeader + buffer.String()); err != nil {
		return err
	}
	return nil
}

func ensurePathExists(path string) error {
	// 检查路径是否存在
	_, err := os.Stat(path)
	if err == nil {
		// 路径存在
		return nil
	}
	if os.IsNotExist(err) {
		// 路径不存在，创建路径
		err := os.MkdirAll(path, 0755)
		if err != nil {
			return fmt.Errorf("无法创建路径 %s: %v", path, err)
		}
		return nil
	}
	// 其他错误
	return fmt.Errorf("无法访问路径 %s: %v", path, err)
}
